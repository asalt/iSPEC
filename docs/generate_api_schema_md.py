#!/usr/bin/env python
"""Generate docs/api-schema.md from live schema.

This script regenerates the API schema documentation by building the
`/schema` responses for each CRUD router listed in :data:`ROUTERS`. The
resulting markdown summary is written next to this script.
"""
from __future__ import annotations

from dataclasses import dataclass, field
from pathlib import Path
import json
import sys
from typing import Callable, Iterable

ROOT = Path(__file__).resolve().parents[1]
sys.path.insert(0, str(ROOT / "src"))

from ispec.db.models import Person, Project, ProjectComment
from ispec.api.models.modelmaker import make_pydantic_model_from_sqlalchemy
from ispec.api.routes.schema import build_form_schema


@dataclass(frozen=True)
class RouterDoc:
    """Configuration describing an autogenerated CRUD router."""

    model: type
    prefix: str
    tag: str
    exclude_fields: set[str] = field(default_factory=lambda: {"id"})
    create_exclude_fields: set[str] = field(default_factory=set)
    optional_all: bool = False

    @property
    def table(self) -> str:
        return self.model.__table__.name  # type: ignore[attr-defined]


ROUTERS: list[RouterDoc] = [
    RouterDoc(
        model=Person,
        prefix="/people",
        tag="Person",
        exclude_fields={"id"},
        create_exclude_fields={"ppl_CreationTS", "ppl_ModificationTS"},
    ),
    RouterDoc(
        model=Project,
        prefix="/projects",
        tag="Project",
        exclude_fields={"id"},
    ),
    RouterDoc(
        model=ProjectComment,
        prefix="/project_comment",
        tag="ProjectComment",
        exclude_fields={"id"},
    ),
]


DOC_TEMPLATE = """<!-- This file is generated by docs/generate_api_schema_md.py -->
# API Schema Generation

This document describes how iSPEC derives JSON schemas with UI hints for its CRUD endpoints.

## Overview

When a router is generated for a SQLAlchemy model, three helper functions collaborate:

1. **`make_pydantic_model_from_sqlalchemy`** converts a SQLAlchemy model into a Pydantic model. It walks each mapped column, determines the Python type and whether the field should be optional, and builds a new `BaseModel` subclass for create or read operations.
2. **`build_form_schema`** takes the SQLAlchemy model and the generated Pydantic model and produces a JSON schema for forms. It starts with `CreateModel.model_json_schema()`, then iterates over each property to attach UI metadata and injects top-level ordering and section information.
3. **`ui_from_column`** inspects individual SQLAlchemy `Column` objects to infer UI metadata such as the component type (`Text`, `Textarea`, `Select`, `SelectAsync`, etc.), `optional` flags for nullable fields, `autofill` flags for defaults, or `optionsEndpoint` for foreign keys.

`generate_crud_router` wires these pieces together for every SQLAlchemy model that we expose through the API.

## Current CRUD Routers

{router_table}

## Generated `/schema` Responses

The sections below show the exact JSON emitted by each autogenerated `/schema` endpoint.

{schema_sections}
"""


def _format_router_table(routers: Iterable[RouterDoc]) -> str:
    rows = ["| Model | Table | Prefix | Tag |", "| --- | --- | --- | --- |"]
    for router in routers:
        rows.append(
            f"| {router.model.__name__} | {router.table} | `{router.prefix}` | `{router.tag}` |"
        )
    return "\n".join(rows)


def _build_schema_json(
    router: RouterDoc, *, route_prefix_for_table: Callable[[str], str] | None
) -> str:
    create_exclude = {*(router.exclude_fields), *(router.create_exclude_fields)}
    CreateModel = make_pydantic_model_from_sqlalchemy(
        router.model,
        name_suffix="Create",
        exclude_fields=create_exclude,
        optional_all=router.optional_all,
    )
    schema = build_form_schema(
        router.model,
        CreateModel,
        route_prefix_for_table=route_prefix_for_table,
    )
    return json.dumps(schema, indent=2)


def _format_schema_sections(
    routers: Iterable[RouterDoc], *, route_prefix_for_table: Callable[[str], str] | None
) -> str:
    sections: list[str] = []
    for router in routers:
        schema_json = _build_schema_json(
            router, route_prefix_for_table=route_prefix_for_table
        )
        sections.append(
            "\n".join(
                [
                    f"### {router.model.__name__} (`{router.prefix}/schema`)",
                    "",
                    "```json",
                    schema_json,
                    "```",
                ]
            )
        )
    return "\n\n".join(sections)


def main() -> None:
    prefix_map = {router.table: router.prefix for router in ROUTERS}

    def route_prefix_for_table(table: str) -> str:
        return prefix_map.get(table, f"/{table}")

    router_table = _format_router_table(ROUTERS)
    schema_sections = _format_schema_sections(
        ROUTERS, route_prefix_for_table=route_prefix_for_table
    )

    doc = DOC_TEMPLATE.format(
        router_table=router_table,
        schema_sections=schema_sections,
    )

    out_path = Path(__file__).with_name("api-schema.md")
    out_path.write_text(doc + "\n")


if __name__ == '__main__':
    main()
